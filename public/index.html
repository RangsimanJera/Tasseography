<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>CPE Tasseography</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,700;1,400&family=Mali:wght@400;600&display=swap"
    rel="stylesheet">

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 40%, #243b55 100%);
      color: #4a3b2a;
      font-family: 'Crimson Pro', serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    body::before {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      background-image:
        radial-gradient(white, rgba(255, 255, 255, .2) 2px, transparent 3px),
        radial-gradient(white, rgba(255, 255, 255, .15) 1px, transparent 2px);
      background-size: 550px 550px, 350px 350px;
      opacity: 0.6;
      z-index: -1;
    }

    canvas {
      display: block;
      filter: drop-shadow(0 10px 40px rgba(0, 0, 0, 0.5));
      transition: transform 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .canvas-reveal {
      transform: translateY(-20%) scale(0.9);
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      transition: opacity 0.5s;
    }

    .ghibli-card {
      pointer-events: auto;
      background: #fdfcf0;
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      border: 2px solid #e0d0a0;
      max-width: 85%;
    }

    .floating-text {
      color: #ffffff !important;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8), 0 0 10px rgba(0, 0, 0, 0.5);
      font-weight: 700;
      font-family: 'Mali', cursive;
      background: rgba(0, 0, 0, 0.3);
      padding: 8px 20px;
      border-radius: 20px;
      backdrop-filter: blur(2px);
      display: inline-block;
      margin-bottom: 20px;
    }

    .floating-header {
      color: #eecda3 !important;
      text-shadow: 2px 2px 5px #2c3e50;
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    h1, h2 {
      color: #2c3e50;
      margin: 10px 0;
      font-weight: 700;
    }

    p {
      color: #5d6d7e;
      font-size: 1.1rem;
      margin-bottom: 25px;
      font-family: 'Mali', cursive;
    }

    .magic-btn {
      display: inline-block;
      padding: 12px 30px;
      margin: 10px;
      background: linear-gradient(to right, #a8e063, #56ab2f);
      border: none;
      border-radius: 50px;
      color: white;
      font-family: 'Mali', cursive;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(86, 171, 47, 0.4);
    }

    .magic-btn.secondary {
      background: linear-gradient(to right, #eecda3, #ef629f);
    }

    input[type="text"] {
      background: rgba(0, 0, 0, 0.05);
      border: none;
      border-bottom: 2px solid #a8e063;
      color: #2c3e50;
      font-size: 1.2rem;
      text-align: center;
      margin-bottom: 20px;
      padding: 10px;
      outline: none;
      font-family: 'Mali', cursive;
      width: 100%;
    }

    #brew-btn {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffecd2, #fcb69f);
      border: 4px solid #fff;
      box-shadow: 0 0 20px rgba(252, 182, 159, 0.6);
      color: #d35400;
      font-weight: bold;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }

    #prediction-box {
      display: none;
      pointer-events: auto;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #fdfcf0 url('https://www.transparenttextures.com/patterns/cream-paper.png');
      padding: 30px 20px;
      box-sizing: border-box;
      border-top: 5px solid #a8e063;
      min-height: 50vh;
      z-index: 100;
      border-radius: 30px 30px 0 0;
      transform: translateY(100%);
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #prediction-box.show {
      transform: translateY(0);
    }

    #result-text {
      font-size: 1.2rem;
      line-height: 1.8;
      border-left: 3px solid #ef629f;
      padding-left: 15px;
      margin: 20px;
      text-align: left;
      font-family: 'Mali', cursive;
    }

    .tilt-icon {
      font-size: 4rem;
      display: block;
      margin-bottom: 20px;
      filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.2));
    }

    /* Shake intensity indicator */
    #shake-meter {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 12px;
      background: rgba(255,255,255,0.2);
      border-radius: 6px;
      overflow: hidden;
      display: none;
      z-index: 20;
    }
    #shake-meter-fill {
      height: 100%;
      background: linear-gradient(to right, #a8e063, #ef629f);
      border-radius: 6px;
      width: 0%;
      transition: width 0.1s;
    }

    #match-hint {
      position: fixed;
      top: 45px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.7);
      font-family: 'Mali', cursive;
      font-size: 0.85rem;
      display: none;
      z-index: 20;
      text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    }
  </style>
</head>

<body>

  <audio id="audio-pour" loop>
    <source src="pour.mp3" type="audio/mpeg">
  </audio>

  <!-- Shake progress indicator -->
  <div id="shake-meter"><div id="shake-meter-fill"></div></div>
  <div id="match-hint"></div>

  <canvas id="canvas"></canvas>

  <div id="ui-layer">
    <div id="screen-select" class="ghibli-card">
      <h2>‡∏£‡πâ‡∏≤‡∏ô‡∏ô‡πâ‡∏≥‡∏ä‡∏≤‡πÅ‡∏´‡πà‡∏á‡πÇ‡∏ä‡∏Ñ‡∏ä‡∏∞‡∏ï‡∏≤</h2>
      <input type="text" id="user-question" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡∏£‡∏π‡πâ..." autocomplete="off">
      <p>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏î‡∏∑‡πà‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
      <button class="magic-btn" onclick="selectDrink('TEA')">üçÉ ‡πÉ‡∏ö‡∏ä‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß</button>
      <button class="magic-btn secondary" onclick="selectDrink('COFFEE')">‚òï ‡∏Å‡∏≤‡πÅ‡∏ü‡∏Ñ‡∏±‡πà‡∏ß</button>
    </div>

    <div id="screen-brew" style="display:none; pointer-events:auto;">
      <p class="floating-text">‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏¥‡∏ô‡∏ô‡πâ‡∏≥‡∏£‡πâ‡∏≠‡∏ô</p>
      <div id="brew-btn">HOLD</div>
    </div>

    <div id="screen-drink" style="display:none; pointer-events:auto; width:100%; text-align:center;">
      <div class="tilt-icon" id="drink-icon">üçµ</div>
      <h2 class="floating-header" id="drink-text">‡∏î‡∏∑‡πà‡∏°‡∏ä‡∏≤</h2>
      <p class="floating-text">‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏≤‡∏ï‡∏±‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∑‡πà‡∏°</p>
      <br>
      <button onclick="debugDrink()"
        style="background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.5); color:#fff; padding:5px 15px; border-radius:15px; margin-top:10px;">‡∏Ç‡πâ‡∏≤‡∏° (Debug)</button>
    </div>

    <div id="screen-shake" style="display:none;">
      <h1 class="floating-header">‡πÄ‡∏Ç‡∏¢‡πà‡∏≤‡πÄ‡∏ö‡∏≤‡πÜ</h1>
      <br>
      <button id="reveal-btn" class="magic-btn"
        style="font-size:1.3rem; padding:15px 40px; display:none; pointer-events:auto; margin-top:20px;">‡πÄ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ ‚ú®</button>
      <br>
      <button onclick="debugShake()"
        style="background:rgba(0,0,0,0.4); border:1px solid rgba(255,255,255,0.4); color:#ccc; padding:5px 15px; border-radius:15px; margin-top:15px; font-family:'Mali',cursive; pointer-events:auto;">‡πÄ‡∏Ç‡∏¢‡πà‡∏≤ (Debug)</button>
    </div>
  </div>

  <div id="prediction-box">
    <h3 style="text-align:center; font-family:'Crimson Pro'; font-size:1.5rem; color:#d35400;">‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏à‡∏≤‡∏Å‡∏Å‡πâ‡∏ô‡∏ñ‡πâ‡∏ß‡∏¢</h3>
    <div style="width: 50px; height: 3px; background: #a8e063; margin: 10px auto 20px; border-radius:2px;"></div>
    <p id="result-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏à‡∏¥‡∏ï‡∏ß‡∏¥‡∏ç‡∏ç‡∏≤‡∏ì...</p>
    <div style="text-align:center; margin-top:30px;">
      <button onclick="location.reload()" class="magic-btn secondary" style="padding:10px 30px;">‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
    </div>
  </div>

  <script>
    // ============================================================
    // TASSEOGRAPHY SYMBOLS
    // ============================================================
    const SYMBOLS = [
      {
        name: "Crescent Moon", nameTH: "‡πÄ‡∏™‡∏µ‡πâ‡∏¢‡∏ß‡∏û‡∏£‡∏∞‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå",
        meaning: "receptivity; lunar; introspection",
        meaningTH: "‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏£‡∏π‡πâ ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏á‡∏ö‡∏†‡∏≤‡∏¢‡πÉ‡∏ô",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = -Math.PI * 0.7; a <= Math.PI * 0.7; a += 0.18)
            pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
          const inner = r * 0.65, ox = r * 0.3;
          for (let a = Math.PI * 0.7; a >= -Math.PI * 0.7; a -= 0.18)
            pts.push({ x: cx + ox + inner * Math.cos(a), y: cy + inner * Math.sin(a) });
          return pts;
        }
      },
      {
        name: "Heart", nameTH: "‡∏´‡∏±‡∏ß‡πÉ‡∏à",
        meaning: "love; romance; home",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å ‚Ä¢ ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ß ‚Ä¢ ‡∏ö‡πâ‡∏≤‡∏ô",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let t = 0; t <= Math.PI * 2; t += 0.12) {
            const x = r * 0.9 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = -r * 0.9 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            pts.push({ x: cx + x, y: cy + y });
          }
          return pts;
        }
      },
      {
        name: "Star", nameTH: "‡∏î‡∏≤‡∏ß",
        meaning: "good luck; excellence; success",
        meaningTH: "‡πÇ‡∏ä‡∏Ñ‡∏î‡∏µ ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        draw: (cx, cy, r) => {
          const pts = [], spikes = 5, inner = r * 0.45;
          for (let i = 0; i < spikes * 2; i++) {
            const rad = i % 2 === 0 ? r : inner;
            const a = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
            const next_rad = (i + 1) % 2 === 0 ? r : inner;
            const next_a = ((i + 1) / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
            for (let t = 0; t <= 1; t += 0.25) {
              const ir = rad + (next_rad - rad) * t;
              const ia = a + (next_a - a) * t;
              pts.push({ x: cx + ir * Math.cos(ia), y: cy + ir * Math.sin(ia) });
            }
          }
          return pts;
        }
      },
      {
        name: "Spiral", nameTH: "‡∏ß‡∏ô‡∏Å‡πâ‡∏ô‡∏´‡∏≠‡∏¢",
        meaning: "creativity; energy; time for problem solving",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏£‡∏£‡∏Ñ‡πå ‚Ä¢ ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô",
        draw: (cx, cy, r) => {
          const pts = [], turns = 2.5;
          for (let t = 0.1; t <= turns * Math.PI * 2; t += 0.15) {
            const rad = (t / (turns * Math.PI * 2)) * r;
            pts.push({ x: cx + rad * Math.cos(t), y: cy + rad * Math.sin(t) });
          }
          return pts;
        }
      },
      {
        name: "Horseshoe", nameTH: "‡πÄ‡∏Å‡∏∑‡∏≠‡∏Å‡∏°‡πâ‡∏≤",
        meaning: "good luck",
        meaningTH: "‡πÇ‡∏ä‡∏Ñ‡∏•‡∏≤‡∏† ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏ä‡∏Ñ‡∏î‡∏µ",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = Math.PI * 0.1; a <= Math.PI * 0.9; a += 0.15)
            pts.push({ x: cx + r * Math.cos(a + Math.PI), y: cy - r * 0.85 * Math.sin(a) });
          for (let y = 0; y <= r * 0.6; y += r * 0.1) pts.push({ x: cx - r * 0.85, y: cy - r * 0.4 + y });
          for (let y = 0; y <= r * 0.6; y += r * 0.1) pts.push({ x: cx + r * 0.85, y: cy - r * 0.4 + y });
          return pts;
        }
      },
      {
        name: "Sun", nameTH: "‡∏î‡∏ß‡∏á‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå",
        meaning: "energy; power; success; new beginnings",
        meaningTH: "‡∏û‡∏•‡∏±‡∏á ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Ä¢ ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI * 2; a += 0.22)
            pts.push({ x: cx + r * 0.45 * Math.cos(a), y: cy + r * 0.45 * Math.sin(a) });
          for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2;
            for (let t = 0.5; t <= 1; t += 0.15)
              pts.push({ x: cx + r * t * Math.cos(a), y: cy + r * t * Math.sin(a) });
          }
          return pts;
        }
      },
      {
        name: "Anchor", nameTH: "‡∏™‡∏°‡∏≠‡πÄ‡∏£‡∏∑‡∏≠",
        meaning: "stability; difficult to change",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡∏Ñ‡∏á ‚Ä¢ ‡∏£‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI * 2; a += 0.3)
            pts.push({ x: cx + r*0.2*Math.cos(a), y: cy - r*0.7 + r*0.2*Math.sin(a) });
          for (let y = -r*0.5; y <= r*0.6; y += r*0.1) pts.push({ x: cx, y: cy + y });
          for (let x = -r*0.5; x <= r*0.5; x += r*0.1) pts.push({ x: cx + x, y: cy - r*0.35 });
          for (let a = 0; a <= Math.PI; a += 0.2)
            pts.push({ x: cx + r*0.55*Math.cos(Math.PI+a), y: cy + r*0.6 + r*0.3*Math.sin(Math.PI+a) });
          pts.push({ x: cx - r*0.55, y: cy + r*0.3 }, { x: cx + r*0.55, y: cy + r*0.3 });
          return pts;
        }
      },
      {
        name: "Cross", nameTH: "‡∏Å‡∏≤‡∏Å‡∏ö‡∏≤‡∏ó",
        meaning: "plus; addition; crossroads",
        meaningTH: "‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏π‡∏ô ‚Ä¢ ‡∏ö‡∏ß‡∏Å ‚Ä¢ ‡∏ó‡∏≤‡∏á‡πÅ‡∏¢‡∏Å",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let y = -r*0.8; y <= r*0.8; y += r*0.1) pts.push({ x: cx, y: cy + y });
          for (let x = -r*0.8; x <= r*0.8; x += r*0.1) pts.push({ x: cx + x, y: cy });
          return pts;
        }
      },
      {
        name: "Water / Waves", nameTH: "‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ô‡πâ‡∏≥",
        meaning: "sea; unity; travel",
        meaningTH: "‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏±‡∏Ñ‡∏Ñ‡∏µ",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let row = -1; row <= 1; row++)
            for (let x = -r*0.85; x <= r*0.85; x += r*0.08)
              pts.push({ x: cx + x, y: cy + row*r*0.3 + Math.sin((x/r)*Math.PI*3)*r*0.12 });
          return pts;
        }
      },
      {
        name: "Arrow Up", nameTH: "‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏Ç‡∏∂‡πâ‡∏ô",
        meaning: "yes; good direction",
        meaningTH: "‡πÉ‡∏ä‡πà ‚Ä¢ ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ ‚Ä¢ ‡∏Å‡πâ‡∏≤‡∏ß‡∏´‡∏ô‡πâ‡∏≤",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let y = -r*0.5; y <= r*0.8; y += r*0.1) pts.push({ x: cx, y: cy + y });
          for (let t = 0; t <= 1; t += 0.1) {
            pts.push({ x: cx - r*0.45*t, y: cy - r*0.5 + r*0.5*t });
            pts.push({ x: cx + r*0.45*t, y: cy - r*0.5 + r*0.5*t });
          }
          return pts;
        }
      },
      {
        name: "Eye / Circle", nameTH: "‡∏ß‡∏á‡∏Å‡∏•‡∏°",
        meaning: "totality; bringing together",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå ‚Ä¢ ‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI*2; a += 0.13)
            pts.push({ x: cx + r*0.75*Math.cos(a), y: cy + r*0.75*Math.sin(a) });
          for (let a = 0; a <= Math.PI*2; a += 0.3)
            pts.push({ x: cx + r*0.15*Math.cos(a), y: cy + r*0.15*Math.sin(a) });
          return pts;
        }
      },
      {
        name: "Peace", nameTH: "‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏™‡∏±‡∏ô‡∏ï‡∏¥",
        meaning: "peace",
        meaningTH: "‡∏™‡∏±‡∏ô‡∏ï‡∏¥‡∏†‡∏≤‡∏û ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏á‡∏ö",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI*2; a += 0.18)
            pts.push({ x: cx + r*0.75*Math.cos(a), y: cy + r*0.75*Math.sin(a) });
          for (let y = -r*0.75; y <= r*0.75; y += r*0.1) pts.push({ x: cx, y: cy + y });
          for (let t = 0; t <= 1; t += 0.12) {
            pts.push({ x: cx - r*0.75*0.7*t, y: cy + r*0.75*0.7*t });
            pts.push({ x: cx + r*0.75*0.7*t, y: cy + r*0.75*0.7*t });
          }
          return pts;
        }
      },
    ];

    // ============================================================
    // SETUP
    // ============================================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const CUP_RADIUS = Math.min(canvas.width, canvas.height) * 0.40;
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;

    let state = 'SELECT';
    let drinkType = 'TEA';
    let liquidLevel = 0;
    let liquidOpacity = 0;
    const audioPour = document.getElementById('audio-pour');

    let particles = [];
    let steamParticles = [];
    let chosenSymbol = null;
    let symbolFormProgress = 0;
    let shakeEnergy = 0;

    // ============================================================
    // PARTICLES
    // ============================================================
    class TeaLeaf {
      constructor(type) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * CUP_RADIUS;
        this.x = CENTER_X + r * Math.cos(angle);
        this.y = CENTER_Y + r * Math.sin(angle);
        this.type = type;
        this.mass = (type === 'LEAF') ? (2.0 + Math.random() * 2.5) : (0.8 + Math.random());
        this.vx = 0; this.vy = 0;
        this.friction = 0.93;
        this.rotation = Math.random();
        this.rotationSpeed = 0;
        this.targetX = null; this.targetY = null;
        this.hasTarget = false;

        // per-particle noise so they don't all move as one blob
        this.noiseOffsetX = (Math.random() - 0.5) * 0.8;
        this.noiseOffsetY = (Math.random() - 0.5) * 0.8;
        this.noisePhase = Math.random() * Math.PI * 2;

        if (drinkType === 'TEA') {
          const green = 50 + Math.random() * 40;
          this.color = `rgba(30, ${green}, 30, ${0.85 + Math.random() * 0.15})`;
        } else {
          const red = 40 + Math.random() * 10;
          this.color = `rgba(${red}, ${red - 10}, ${red - 20}, ${0.9 + Math.random() * 0.1})`;
        }

        this.vertices = [];
        let size = (type === 'LEAF') ? this.mass * 4 : this.mass * 2;
        let points = 4 + Math.floor(Math.random() * 4);
        for (let i = 0; i < points; i++) {
          let th = (i / points) * Math.PI * 2;
          let rad = size * (0.6 + Math.random() * 0.4);
          this.vertices.push({ x: Math.cos(th) * rad, y: Math.sin(th) * rad });
        }
      }

      update(inputLow) {
        if (state !== 'SHAKE') return;

        this.noisePhase += 0.04;

        // Pull toward target when settling
        if (this.hasTarget && symbolFormProgress > 0) {
          const pull = symbolFormProgress * 0.08;
          this.vx += (this.targetX - this.x) * pull;
          this.vy += (this.targetY - this.y) * pull;
        }

        let currentFriction = inputLow ? 0.82 : this.friction;

        // Per-particle variation: each leaf reacts slightly differently
        const personalScale = 0.6 + this.mass * 0.25;
        const noiseX = inputLow ? 0 : Math.sin(this.noisePhase + this.noiseOffsetX * 5) * 0.4;
        const noiseY = inputLow ? 0 : Math.cos(this.noisePhase * 0.7 + this.noiseOffsetY * 5) * 0.4;

        this.vx -= ((accX + noiseX) * 1.8 * personalScale) / this.mass;
        this.vy -= ((accY + noiseY) * 1.8 * personalScale) / this.mass;
        this.vx += tiltX * 0.05;
        this.vy += tiltY * 0.05;
        this.vx *= currentFriction;
        this.vy *= currentFriction;

        // Repulsion only while actively shaking ‚Äî stops when input is low so particles can settle
        if (!inputLow) {
          const repulseRadius = 14;
          const repulseForce = 0.35;
          for (let i = 0; i < particles.length; i += 6) {
            const other = particles[i];
            if (other === this) continue;
            const rx = this.x - other.x;
            const ry = this.y - other.y;
            const d2 = rx * rx + ry * ry;
            if (d2 < repulseRadius * repulseRadius && d2 > 0.01) {
              const d = Math.sqrt(d2);
              const f = (repulseRadius - d) / repulseRadius * repulseForce;
              this.vx += (rx / d) * f;
              this.vy += (ry / d) * f;
            }
          }
        }

        this.x += this.vx;
        this.y += this.vy;

        const dx = this.x - CENTER_X;
        const dy = this.y - CENTER_Y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > CUP_RADIUS) {
          let ang = Math.atan2(dy, dx);
          this.x = CENTER_X + Math.cos(ang) * CUP_RADIUS;
          this.y = CENTER_Y + Math.sin(ang) * CUP_RADIUS;
          this.vx *= -0.2;
          this.vy *= -0.2;
        }
      }

      draw() {
        let alpha = 1;
        if (state === 'BREW') alpha = 0.1;
        if (state === 'DRINK') alpha = 1 - liquidOpacity;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    class Steam {
      constructor() {
        this.x = CENTER_X + (Math.random() - 0.5) * CUP_RADIUS;
        this.y = CENTER_Y + (Math.random() - 0.5) * CUP_RADIUS;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = -0.5 - Math.random() * 0.5;
        this.size = 5 + Math.random() * 15;
        this.life = 150;
      }
      update() { this.x += this.vx; this.y += this.vy; this.size += 0.15; this.life -= 1; }
      draw() {
        ctx.save();
        ctx.globalAlpha = (this.life / 150) * 0.2;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // ============================================================
    // SYMBOL MATCHING ‚Äî ‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
    // ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á particle ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏≤ symbol ‡∏ó‡∏µ‡πà match ‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    // ============================================================

    /**
     * ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì "feature vector" ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏° particle:
     * ‡πÅ‡∏ö‡πà‡∏á cup ‡πÄ‡∏õ‡πá‡∏ô grid ‡πÅ‡∏•‡∏∞‡∏ô‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ã‡∏•‡∏•‡πå
     */
    function computeDensityGrid(pts, gridSize = 8) {
      const grid = new Float32Array(gridSize * gridSize);
      for (const p of pts) {
        // normalize to [-1, 1]
        const nx = (p.x - CENTER_X) / CUP_RADIUS;
        const ny = (p.y - CENTER_Y) / CUP_RADIUS;
        const gx = Math.floor((nx + 1) / 2 * gridSize);
        const gy = Math.floor((ny + 1) / 2 * gridSize);
        if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize) {
          grid[gy * gridSize + gx]++;
        }
      }
      // normalize
      const max = Math.max(...grid, 1);
      for (let i = 0; i < grid.length; i++) grid[i] /= max;
      return grid;
    }

    /**
     * ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì feature vector ‡∏Ç‡∏≠‡∏á symbol (‡∏à‡∏≤‡∏Å draw points)
     * ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö particle pattern
     */
    function computeSymbolGrid(symbol, gridSize = 8) {
      const rawPts = symbol.draw(CENTER_X, CENTER_Y, CUP_RADIUS * 0.75);
      return computeDensityGrid(rawPts, gridSize);
    }

    /**
     * ‡∏´‡∏≤ symbol ‡∏ó‡∏µ‡πà particle pattern ‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
     * ‡πÉ‡∏ä‡πâ cosine similarity + spatial moment matching
     */
    function findBestMatchingSymbol() {
      const particlePts = particles.map(p => ({ x: p.x, y: p.y }));
      const particleGrid = computeDensityGrid(particlePts);

      // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì spatial moments ‡∏Ç‡∏≠‡∏á particles
      const particleMoments = computeSpatialMoments(particlePts);

      let bestSymbol = null;
      let bestScore = -Infinity;

      for (const sym of SYMBOLS) {
        const symGrid = computeSymbolGrid(sym);
        const symPts = sym.draw(CENTER_X, CENTER_Y, CUP_RADIUS * 0.75);
        const symMoments = computeSpatialMoments(symPts);

        // Cosine similarity ‡∏Ç‡∏≠‡∏á density grid
        const cosSim = cosineSimilarity(particleGrid, symGrid);

        // Moment similarity
        const momentSim = momentSimilarity(particleMoments, symMoments);

        // Weighted score
        const score = cosSim * 0.6 + momentSim * 0.4;

        if (score > bestScore) {
          bestScore = score;
          bestSymbol = sym;
        }
      }

      return { symbol: bestSymbol, confidence: bestScore };
    }

    function cosineSimilarity(a, b) {
      let dot = 0, normA = 0, normB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      if (normA === 0 || normB === 0) return 0;
      return dot / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    /**
     * ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì spatial moments: centroid, variance, skewness ‡∏Ç‡∏≠‡∏á x,y
     */
    function computeSpatialMoments(pts) {
      if (pts.length === 0) return { cx: 0, cy: 0, vx: 0, vy: 0, sx: 0, sy: 0, radialVar: 0 };

      const nx = pts.map(p => (p.x - CENTER_X) / CUP_RADIUS);
      const ny = pts.map(p => (p.y - CENTER_Y) / CUP_RADIUS);
      const n = pts.length;

      const cx = nx.reduce((s, v) => s + v, 0) / n;
      const cy = ny.reduce((s, v) => s + v, 0) / n;

      const vx = nx.reduce((s, v) => s + (v - cx)**2, 0) / n;
      const vy = ny.reduce((s, v) => s + (v - cy)**2, 0) / n;

      const sx = vx > 0 ? nx.reduce((s, v) => s + (v - cx)**3, 0) / n / vx**1.5 : 0;
      const sy = vy > 0 ? ny.reduce((s, v) => s + (v - cy)**3, 0) / n / vy**1.5 : 0;

      // radial distribution variance (‡∏ß‡∏±‡∏î‡∏ß‡πà‡∏≤‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏≠‡∏≠‡∏Å‡∏Ç‡∏≠‡∏ö‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏ß‡∏°‡∏Å‡∏•‡∏≤‡∏á)
      const radials = pts.map(p => Math.sqrt((p.x - CENTER_X)**2 + (p.y - CENTER_Y)**2) / CUP_RADIUS);
      const meanR = radials.reduce((s, v) => s + v, 0) / n;
      const radialVar = radials.reduce((s, v) => s + (v - meanR)**2, 0) / n;

      return { cx, cy, vx, vy, sx, sy, radialVar };
    }

    function momentSimilarity(a, b) {
      const keys = ['cx', 'cy', 'vx', 'vy', 'radialVar'];
      let sim = 0;
      for (const k of keys) {
        const diff = Math.abs(a[k] - b[k]);
        sim += Math.exp(-diff * 3); // Gaussian similarity
      }
      return sim / keys.length;
    }

    // ============================================================
    // ASSIGN TARGETS ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å match symbol ‡πÅ‡∏•‡πâ‡∏ß
    // ============================================================
    function assignTargetsToSymbol(symbol) {
      chosenSymbol = symbol;
      const rawPts = symbol.draw(CENTER_X, CENTER_Y, CUP_RADIUS * 0.75);

      particles.forEach((p, i) => {
        const tp = rawPts[i % rawPts.length];
        p.targetX = tp.x + (Math.random() - 0.5) * 18;
        p.targetY = tp.y + (Math.random() - 0.5) * 18;
        p.hasTarget = true;
      });
    }

    // ============================================================
    // GAME LOOP
    // ============================================================
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.beginPath();
      ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS, 0, Math.PI * 2);
      let grad = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, CUP_RADIUS);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.8, '#f4f1ea');
      grad.addColorStop(1, '#e0d8c0');
      ctx.fillStyle = grad; ctx.fill();
      ctx.clip();

      let isLow = checkSettled();
      particles.forEach(p => {
        if (state === 'SHAKE') p.update(isLow);
        p.draw();
      });

      if (liquidOpacity > 0) {
        if (drinkType === 'TEA') ctx.fillStyle = `rgba(100, 130, 50, ${liquidOpacity * 0.95})`;
        else ctx.fillStyle = `rgba(40, 20, 10, ${liquidOpacity * 0.95})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = `rgba(255,255,255, ${liquidOpacity * 0.1})`;
        ctx.beginPath();
        ctx.arc(CENTER_X - CUP_RADIUS*0.3, CENTER_Y - CUP_RADIUS*0.3, CUP_RADIUS*0.1, 0, Math.PI*2);
        ctx.fill();
      }

      steamParticles.forEach((s, i) => { s.update(); s.draw(); if (s.life <= 0) steamParticles.splice(i, 1); });
      ctx.restore();

      ctx.strokeStyle = '#c5a059'; ctx.lineWidth = 12;
      ctx.beginPath(); ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS, 0, Math.PI * 2); ctx.stroke();
      ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS - 6, 0, Math.PI * 2); ctx.stroke();

      requestAnimationFrame(loop);
    }

    // ============================================================
    // LOGIC
    // ============================================================
    // ============================================================
    // LOGIC
    // ============================================================
    window.selectDrink = async (type) => {
      drinkType = type;

      if (type === 'TEA') {
        document.getElementById('drink-icon').innerText = 'üçµ';
        document.getElementById('drink-text').innerText = '‡∏î‡∏∑‡πà‡∏°‡∏ä‡∏≤';
      } else {
        document.getElementById('drink-icon').innerText = '‚òï';
        document.getElementById('drink-text').innerText = '‡∏î‡∏∑‡πà‡∏°‡∏Å‡∏≤‡πÅ‡∏ü‡∏Ñ‡∏±‡πà‡∏ß';
      }

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceOrientationEvent.requestPermission();
          if (permission !== 'granted') {
            alert('‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏ã‡∏ô‡πÄ‡∏ã‡∏≠‡∏£‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡∏ñ‡∏∂‡∏á‡∏à‡∏∞‡πÄ‡∏Ç‡∏¢‡πà‡∏≤‡πÅ‡∏Å‡πâ‡∏ß‡πÑ‡∏î‡πâ‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö!');
          }
        } catch (error) {
          console.error("Sensor permission error:", error);
        }
      }

      document.getElementById('screen-select').style.display = 'none';
      document.getElementById('screen-brew').style.display = 'block';
      state = 'BREW';
      initParticles();
    };

    function initParticles() {
      particles = [];
      for (let i = 0; i < 800; i++) {
        let t = Math.random() > 0.6 ? 'LEAF' : 'DUST';
        particles.push(new TeaLeaf(t));
      }
      loop();
    }

    const brewBtn = document.getElementById('brew-btn');
    let brewInterval;

    const startBrewAction = (e) => {
      if (e) e.preventDefault();
      if (liquidLevel >= 100) return;
      try { audioPour.play(); } catch (e) { }
      brewInterval = setInterval(() => {
        if (liquidLevel < 100) {
          liquidLevel += 1;
          liquidOpacity = liquidLevel / 100;
          brewBtn.innerText = `${Math.floor(liquidLevel)}%`;
          if (Math.random() > 0.5) steamParticles.push(new Steam());
        } else { finishBrew(); }
      }, 30);
    };

    const stopBrewAction = () => {
      clearInterval(brewInterval);
      audioPour.pause(); audioPour.currentTime = 0;
    };

    brewBtn.addEventListener('touchstart', startBrewAction);
    brewBtn.addEventListener('mousedown', startBrewAction);
    brewBtn.addEventListener('touchend', stopBrewAction);
    brewBtn.addEventListener('mouseup', stopBrewAction);

    function finishBrew() {
      stopBrewAction();
      document.getElementById('screen-brew').style.display = 'none';
      document.getElementById('screen-drink').style.display = 'block';
      state = 'DRINK';
      window.addEventListener('deviceorientation', handleDrinkTilt);
    }

    function handleDrinkTilt(event) {
      if (state !== 'DRINK') return;
      const tilt = event.beta;
      
      // ‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏Å‡∏ã‡∏î ‡∏Å‡πá‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏î‡∏∑‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß (‡∏î‡∏∑‡πà‡∏°‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô)
      if (tilt > 75 && liquidLevel > 0) {
        liquidLevel -= 1; 
        liquidOpacity = liquidLevel / 100;
        if (liquidLevel <= 0) finishDrink();
      }
    }

    window.debugDrink = () => {
      let drinkInt = setInterval(() => {
        liquidLevel -= 5;
        liquidOpacity = liquidLevel / 100;
        if (liquidLevel <= 0) { clearInterval(drinkInt); finishDrink(); }
      }, 20);
    };

    function finishDrink() {
      window.removeEventListener('deviceorientation', handleDrinkTilt);
      document.getElementById('screen-drink').style.display = 'none';
      document.getElementById('screen-shake').style.display = 'block';
      state = 'SHAKE';

      // ‡πÅ‡∏™‡∏î‡∏á shake meter
      document.getElementById('shake-meter').style.display = 'block';
      document.getElementById('match-hint').style.display = 'block';

      window.addEventListener('devicemotion', handleMotion);
      window.addEventListener('deviceorientation', handleOrientation);
    }

    // ============================================================
    // SHAKE SENSORS
    // ============================================================
    let accX = 0, accY = 0, tiltX = 0, tiltY = 0;
    let prevAccX = 0, prevAccY = 0;

    function handleMotion(e) {
      let acc = e.acceleration || e.accelerationIncludingGravity;
      if (acc) {
        let rx = acc.x || 0; let ry = acc.y || 0;
        accX = (Math.abs(rx) < 0.5) ? 0 : rx;
        accY = (Math.abs(ry) < 0.5) ? 0 : ry;
        shakeEnergy = Math.abs(accX - prevAccX) + Math.abs(accY - prevAccY);
        prevAccX = accX; prevAccY = accY;
      }
    }

    function handleOrientation(e) {
      tiltX = e.gamma || 0;
      tiltY = e.beta || 0;
    }

    window.debugShake = () => {
      // Give each particle an initial random kick to break the clump
      particles.forEach(p => {
        const angle = Math.random() * Math.PI * 2;
        const force = 8 + Math.random() * 10;
        p.vx += Math.cos(angle) * force;
        p.vy += Math.sin(angle) * force;
      });

      let t = 0;
      const iv = setInterval(() => {
        // Oscillating shake ‚Äî alternating directions like real hand shake
        const phase = t * 0.4;
        accX = Math.sin(phase) * 10 + (Math.random() - 0.5) * 6;
        accY = Math.cos(phase * 1.3) * 10 + (Math.random() - 0.5) * 6;
        shakeEnergy = 10;
        t++;
        if (t > 40) { clearInterval(iv); accX = 0; accY = 0; shakeEnergy = 0; }
      }, 40);
    };

    // ============================================================
    // SETTLE / SYMBOL MATCHING LOGIC (‡πÉ‡∏´‡∏°‡πà)
    // ============================================================
    let stillFrames = 0;
    const revealBtn = document.getElementById('reveal-btn');

    let hasShaken = false;
    let totalShakeEnergy = 0;
    const SHAKE_THRESHOLD = 80;

    // State ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ matching
    let matchingDone = false;
    let lastMatchTime = 0;
    const MATCH_COOLDOWN = 500; // ms ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£ re-match

    function checkSettled() {
      if (state !== 'SHAKE') return true;
      let force = Math.abs(accX) + Math.abs(accY);
      let isInputLow = force < 2.5;

      if (!isInputLow) {
        totalShakeEnergy += shakeEnergy;
        if (totalShakeEnergy >= SHAKE_THRESHOLD) {
          hasShaken = true;
          matchingDone = false; // reset matching ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ match ‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î
        }
        // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï shake meter
        const pct = Math.min(totalShakeEnergy / SHAKE_THRESHOLD * 100, 100);
        document.getElementById('shake-meter-fill').style.width = pct + '%';
      }

      let vel = 0;
      for (let i = 0; i < particles.length; i += 10) vel += Math.abs(particles[i].vx) + Math.abs(particles[i].vy);
      vel /= (particles.length / 10);

      if (hasShaken && isInputLow && vel < 1.5) {
        stillFrames++;

        // ===== MATCHING: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á particle ‡∏à‡∏£‡∏¥‡∏á‡πÅ‡∏•‡∏∞‡∏´‡∏≤ symbol ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á =====
        if (!matchingDone && stillFrames === 60) {
          const now = Date.now();
          if (now - lastMatchTime > MATCH_COOLDOWN) {
            lastMatchTime = now;
            const { symbol, confidence } = findBestMatchingSymbol();
            assignTargetsToSymbol(symbol);
            matchingDone = true;

            // ‡πÅ‡∏™‡∏î‡∏á hint
            const hint = document.getElementById('match-hint');
            hint.textContent = `‚ú® ‡πÄ‡∏´‡πá‡∏ô ${symbol.nameTH} ‡∏≠‡∏¢‡∏π‡πà...`;
          }
        }

        if (symbolFormProgress < 1 && matchingDone)
          symbolFormProgress = Math.min(1, symbolFormProgress + 0.004);

      } else {
        if (!hasShaken || !isInputLow) {
          stillFrames = 0;
          revealBtn.style.display = 'none';
          if (!isInputLow) {
            // user ‡πÄ‡∏Ç‡∏¢‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà ‚Äî reset matching ‡πÄ‡∏û‡∏∑‡πà‡∏≠ match ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î
            matchingDone = false;
            symbolFormProgress = Math.max(0, symbolFormProgress - 0.02);
            // ‡∏•‡πâ‡∏≤‡∏á target ‡πÄ‡∏Å‡πà‡∏≤
            particles.forEach(p => { p.hasTarget = false; });
            // ‡∏ã‡πà‡∏≠‡∏ô hint ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß
            document.getElementById('match-hint').textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á...';
          }
        }
        if (hasShaken && !isInputLow)
          symbolFormProgress = Math.max(0, symbolFormProgress - 0.02);
      }

      if (hasShaken && stillFrames > 30) revealBtn.style.display = 'block';
      return isInputLow;
    }

    // ============================================================
    // REVEAL
    // ============================================================
    revealBtn.addEventListener('click', async () => {
      state = 'REVEAL';
      document.getElementById('ui-layer').style.display = 'none';
      document.getElementById('shake-meter').style.display = 'none';
      document.getElementById('match-hint').style.display = 'none';
      canvas.classList.add('canvas-reveal');

      const pBox = document.getElementById('prediction-box');
      pBox.style.display = 'block';
      setTimeout(() => pBox.classList.add('show'), 100);

      if (chosenSymbol) {
        document.getElementById('result-text').innerHTML =
          `<strong>‚ú® ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏≤‡∏Å‡∏è: ${chosenSymbol.nameTH}</strong><br>` +
          `<em>(${chosenSymbol.name})</em><br><br>` +
          `‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢: ${chosenSymbol.meaningTH}<br><br>` +
          `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏à‡∏¥‡∏ï‡∏ß‡∏¥‡∏ç‡∏ç‡∏≤‡∏ì...`;
      }

      // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏≤‡∏Å‡∏£‡∏π‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ä‡πà‡∏ß‡∏¢ AI ‡∏ú‡∏π‡∏Å‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏≤‡∏°
      const userQuestion = document.getElementById('user-question')?.value || '';

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000);

      try {
        const res = await fetch('/api/predict', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbolName: chosenSymbol ? chosenSymbol.name : '',
            symbolMeaning: chosenSymbol ? chosenSymbol.meaning : '',
            symbolNameTH: chosenSymbol ? chosenSymbol.nameTH : '',
            symbolMeaningTH: chosenSymbol ? chosenSymbol.meaningTH : '',
            userQuestion
          }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const data = await res.json();
        if (data.success) {
          document.getElementById('result-text').innerHTML =
            `<strong>‚ú® ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå: ${chosenSymbol ? chosenSymbol.nameTH : ''}</strong><br><br>` +
            data.prediction;
        } else {
          document.getElementById('result-text').innerText = "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏∑‡∏î‡∏ö‡∏î‡∏ö‡∏±‡∏á... ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà";
        }
      } catch (e) {
        clearTimeout(timeoutId);
        let msg = "‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢...";
        if (e.name === 'AbortError') msg = "‡∏£‡∏≠‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ... ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
        if (chosenSymbol) {
          document.getElementById('result-text').innerHTML =
            `<strong>‚ú® ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏≤‡∏Å‡∏è: ${chosenSymbol.nameTH}</strong><br><br>` +
            `${chosenSymbol.meaningTH}<br><br><em>${msg}</em>`;
        } else {
          document.getElementById('result-text').innerText = msg;
        }
      }
    });

  </script>
</body>
</html>