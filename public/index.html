<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tea Reading: Ghibli Edition</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,700;1,400&family=Mali:wght@400;600&display=swap"
    rel="stylesheet">

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 40%, #243b55 100%);
      color: #4a3b2a;
      font-family: 'Crimson Pro', serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    body::before {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      background-image:
        radial-gradient(white, rgba(255, 255, 255, .2) 2px, transparent 3px),
        radial-gradient(white, rgba(255, 255, 255, .15) 1px, transparent 2px);
      background-size: 550px 550px, 350px 350px;
      opacity: 0.6;
      z-index: -1;
    }

    canvas {
      display: block;
      filter: drop-shadow(0 10px 40px rgba(0, 0, 0, 0.5));
      transition: transform 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }

    .canvas-reveal {
      transform: translateY(-20%) scale(0.9);
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      transition: opacity 0.5s;
    }

    /* CARD STYLE (‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å) - ‡∏≠‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß */
    .ghibli-card {
      pointer-events: auto;
      background: #fdfcf0;
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      border: 2px solid #e0d0a0;
      max-width: 85%;
    }

    /* --- NEW: FLOATING TEXT STYLE (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏•‡∏≠‡∏¢‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡∏ñ‡πâ‡∏ß‡∏¢) --- */
    .floating-text {
      color: #ffffff !important;
      /* ‡∏™‡∏µ‡∏Ç‡∏≤‡∏ß‡∏•‡πâ‡∏ß‡∏ô */
      text-shadow:
        0 2px 4px rgba(0, 0, 0, 0.8),
        /* ‡πÄ‡∏á‡∏≤‡∏•‡∏∂‡∏Å */
        0 0 10px rgba(0, 0, 0, 0.5);
      /* ‡πÄ‡∏£‡∏∑‡∏≠‡∏á‡πÅ‡∏™‡∏á‡∏£‡∏≠‡∏ö‡πÜ */
      font-weight: 700;
      font-family: 'Mali', cursive;
      background: rgba(0, 0, 0, 0.3);
      /* ‡∏£‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏à‡∏≤‡∏á‡πÜ */
      padding: 8px 20px;
      border-radius: 20px;
      backdrop-filter: blur(2px);
      display: inline-block;
      margin-bottom: 20px;
    }

    .floating-header {
      color: #eecda3 !important;
      text-shadow: 2px 2px 5px #2c3e50;
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    h1,
    h2 {
      color: #2c3e50;
      margin: 10px 0;
      font-weight: 700;
    }

    p {
      color: #5d6d7e;
      font-size: 1.1rem;
      margin-bottom: 25px;
      font-family: 'Mali', cursive;
    }

    .magic-btn {
      display: inline-block;
      padding: 12px 30px;
      margin: 10px;
      background: linear-gradient(to right, #a8e063, #56ab2f);
      border: none;
      border-radius: 50px;
      color: white;
      font-family: 'Mali', cursive;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(86, 171, 47, 0.4);
    }

    .magic-btn.secondary {
      background: linear-gradient(to right, #eecda3, #ef629f);
    }

    input[type="text"] {
      background: rgba(0, 0, 0, 0.05);
      border: none;
      border-bottom: 2px solid #a8e063;
      color: #2c3e50;
      font-size: 1.2rem;
      text-align: center;
      margin-bottom: 20px;
      padding: 10px;
      outline: none;
      font-family: 'Mali', cursive;
      width: 100%;
    }

    #brew-btn {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffecd2, #fcb69f);
      border: 4px solid #fff;
      box-shadow: 0 0 20px rgba(252, 182, 159, 0.6);
      color: #d35400;
      font-weight: bold;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0% {
        transform: translateY(0px);
      }

      50% {
        transform: translateY(-10px);
      }

      100% {
        transform: translateY(0px);
      }
    }

    #prediction-box {
      display: none;
      pointer-events: auto;
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #fdfcf0 url('https://www.transparenttextures.com/patterns/cream-paper.png');
      padding: 30px 20px;
      box-sizing: border-box;
      border-top: 5px solid #a8e063;
      min-height: 50vh;
      z-index: 100;
      border-radius: 30px 30px 0 0;
      transform: translateY(100%);
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    #prediction-box.show {
      transform: translateY(0);
    }

    #result-text {
      font-size: 1.2rem;
      line-height: 1.8;
      border-left: 3px solid #ef629f;
      padding-left: 15px;
      margin: 20px;
      text-align: left;
      font-family: 'Mali', cursive;
    }

    .tilt-icon {
      font-size: 4rem;
      display: block;
      margin-bottom: 20px;
      filter: drop-shadow(0 5px 5px rgba(0, 0, 0, 0.2));
    }
  </style>
</head>

<body>

  <audio id="audio-pour" loop>
    <source src="pour.mp3" type="audio/mpeg">
  </audio>

  <canvas id="canvas"></canvas>

  <div id="ui-layer">
    <div id="screen-select" class="ghibli-card">
      <h2>‡∏£‡πâ‡∏≤‡∏ô‡∏ô‡πâ‡∏≥‡∏ä‡∏≤‡πÅ‡∏´‡πà‡∏á‡πÇ‡∏ä‡∏Ñ‡∏ä‡∏∞‡∏ï‡∏≤</h2>
      <input type="text" id="user-question" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡∏£‡∏π‡πâ..." autocomplete="off">
      <p>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ö‡∏ä‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
      <button class="magic-btn" onclick="selectDrink('TEA')">üçÉ ‡πÉ‡∏ö‡∏ä‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß</button>
      <button class="magic-btn secondary" onclick="selectDrink('COFFEE')">‚òï ‡∏Å‡∏≤‡πÅ‡∏ü‡∏Ñ‡∏±‡πà‡∏ß</button>
    </div>

    <div id="screen-brew" style="display:none; pointer-events:auto;">
      <p class="floating-text">‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏¥‡∏ô‡∏ô‡πâ‡∏≥‡∏£‡πâ‡∏≠‡∏ô</p>
      <div id="brew-btn">HOLD</div>
    </div>

    <div id="screen-drink" style="display:none; pointer-events:auto; width:100%; text-align:center;">
      <div class="tilt-icon">üçµ</div>
      <h2 class="floating-header">‡∏î‡∏∑‡πà‡∏°‡∏ä‡∏≤</h2>
      <p class="floating-text">‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏≤‡∏ï‡∏±‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∑‡πà‡∏°</p>
      <br>
      <button onclick="debugDrink()"
        style="background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.5); color:#fff; padding:5px 15px; border-radius:15px; margin-top:10px;">‡∏Ç‡πâ‡∏≤‡∏°
        (Debug)</button>
    </div>

    <div id="screen-shake" style="display:none;">
      <h1 class="floating-header">‡πÄ‡∏Ç‡∏¢‡πà‡∏≤‡πÄ‡∏ö‡∏≤‡πÜ</h1>
      <p class="floating-text">‡πÉ‡∏´‡πâ‡πÉ‡∏ö‡∏ä‡∏≤‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ï‡∏±‡∏ß...</p>
      <br>
      <button id="reveal-btn" class="magic-btn"
        style="font-size:1.3rem; padding:15px 40px; display:none; pointer-events:auto; margin-top:20px;">‡πÄ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢
        ‚ú®</button>
    </div>
  </div>

  <div id="prediction-box">
    <h3 style="text-align:center; font-family:'Crimson Pro'; font-size:1.5rem; color:#d35400;">‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏à‡∏≤‡∏Å‡∏Å‡πâ‡∏ô‡∏ñ‡πâ‡∏ß‡∏¢</h3>
    <div style="width: 50px; height: 3px; background: #a8e063; margin: 10px auto 20px; border-radius:2px;"></div>
    <p id="result-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏à‡∏¥‡∏ï‡∏ß‡∏¥‡∏ç‡∏ç‡∏≤‡∏ì...</p>
    <div style="text-align:center; margin-top:30px;">
      <button onclick="location.reload()" class="magic-btn secondary"
        style="padding:10px 30px;">‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
    </div>
  </div>

  <script>
    // --- SETUP ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const CUP_RADIUS = Math.min(canvas.width, canvas.height) * 0.40;
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;

    // State Management
    let state = 'SELECT';
    let drinkType = 'TEA';
    let liquidLevel = 0;
    let liquidOpacity = 0;
    const audioPour = document.getElementById('audio-pour');

    // --- PARTICLES SYSTEM ---
    let particles = [];
    let steamParticles = [];

    class TeaLeaf {
      constructor(type) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * CUP_RADIUS;
        this.x = CENTER_X + r * Math.cos(angle);
        this.y = CENTER_Y + r * Math.sin(angle);
        this.type = type;
        this.mass = (type === 'LEAF') ? (2.0 + Math.random() * 2.5) : (0.8 + Math.random());

        this.vx = 0;
        this.vy = 0;
        this.friction = 0.93;
        this.rotation = Math.random();
        this.rotationSpeed = 0;

        if (drinkType === 'TEA') {
          const green = 50 + Math.random() * 40;
          this.color = `rgba(30, ${green}, 30, ${0.85 + Math.random() * 0.15})`;
        } else {
          const red = 40 + Math.random() * 10;
          this.color = `rgba(${red}, ${red - 10}, ${red - 20}, ${0.9 + Math.random() * 0.1})`;
        }

        this.vertices = [];
        let size = (type === 'LEAF') ? this.mass * 4 : this.mass * 2;
        let points = 4 + Math.floor(Math.random() * 4);
        for (let i = 0; i < points; i++) {
          let th = (i / points) * Math.PI * 2;
          let rad = size * (0.6 + Math.random() * 0.4);
          this.vertices.push({ x: Math.cos(th) * rad, y: Math.sin(th) * rad });
        }
      }

      update(inputLow) {
        if (state !== 'SHAKE') return;

        let currentFriction = inputLow ? 0.89 : this.friction;
        this.vx -= (accX * 1.8) / this.mass;
        this.vy -= (accY * 1.8) / this.mass;
        this.vx += tiltX * 0.05;
        this.vy += tiltY * 0.05;
        this.vx *= currentFriction;
        this.vy *= currentFriction;
        this.x += this.vx;
        this.y += this.vy;

        const dx = this.x - CENTER_X;
        const dy = this.y - CENTER_Y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > CUP_RADIUS) {
          let ang = Math.atan2(dy, dx);
          this.x = CENTER_X + Math.cos(ang) * CUP_RADIUS;
          this.y = CENTER_Y + Math.sin(ang) * CUP_RADIUS;
          this.vx *= -0.2;
          this.vy *= -0.2;
        }
      }

      draw() {
        let alpha = 1;
        if (state === 'BREW') alpha = 0.1;
        if (state === 'DRINK') alpha = 1 - liquidOpacity;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.beginPath();

        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    class Steam {
      constructor() {
        this.x = CENTER_X + (Math.random() - 0.5) * CUP_RADIUS;
        this.y = CENTER_Y + (Math.random() - 0.5) * CUP_RADIUS;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = -0.5 - Math.random() * 0.5;
        this.size = 5 + Math.random() * 15;
        this.life = 150;
      }
      update() {
        this.x += this.vx; this.y += this.vy;
        this.size += 0.15; this.life -= 1;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = (this.life / 150) * 0.2;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // --- GAME LOOP ---
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 1. Cup Base
      ctx.save();
      ctx.beginPath();
      ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS, 0, Math.PI * 2);
      let grad = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, CUP_RADIUS);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.8, '#f4f1ea');
      grad.addColorStop(1, '#e0d8c0');
      ctx.fillStyle = grad; ctx.fill();
      ctx.clip();

      // 2. Leaves
      let isLow = checkSettled();
      particles.forEach(p => {
        if (state === 'SHAKE') p.update(isLow);
        p.draw();
      });

      // 3. Liquid
      if (liquidOpacity > 0) {
        if (drinkType === 'TEA') {
          ctx.fillStyle = `rgba(100, 130, 50, ${liquidOpacity * 0.95})`;
        } else {
          ctx.fillStyle = `rgba(40, 20, 10, ${liquidOpacity * 0.95})`;
        }
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = `rgba(255,255,255, ${liquidOpacity * 0.1})`;
        ctx.beginPath();
        ctx.arc(CENTER_X - CUP_RADIUS * 0.3, CENTER_Y - CUP_RADIUS * 0.3, CUP_RADIUS * 0.1, 0, Math.PI * 2);
        ctx.fill();
      }

      // 4. Steam
      steamParticles.forEach((s, index) => {
        s.update(); s.draw();
        if (s.life <= 0) steamParticles.splice(index, 1);
      });

      ctx.restore();

      // 5. Rim
      ctx.strokeStyle = '#c5a059';
      ctx.lineWidth = 12;
      ctx.beginPath(); ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS, 0, Math.PI * 2); ctx.stroke();

      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS - 6, 0, Math.PI * 2); ctx.stroke();

      requestAnimationFrame(loop);
    }

    // --- LOGIC ---
    window.selectDrink = (type) => {
      drinkType = type;
      document.getElementById('screen-select').style.display = 'none';
      document.getElementById('screen-brew').style.display = 'block';
      state = 'BREW';
      initParticles();
    };

    function initParticles() {
      particles = [];
      for (let i = 0; i < 800; i++) {
        let t = Math.random() > 0.6 ? 'LEAF' : 'DUST';
        particles.push(new TeaLeaf(t));
      }
      loop();
    }

    const brewBtn = document.getElementById('brew-btn');
    let brewInterval;

    const startBrewAction = (e) => {
      if (e) e.preventDefault();
      if (liquidLevel >= 100) return;
      try { audioPour.play(); } catch (e) { }
      brewInterval = setInterval(() => {
        if (liquidLevel < 100) {
          liquidLevel += 1;
          liquidOpacity = liquidLevel / 100;
          brewBtn.innerText = `${Math.floor(liquidLevel)}%`;
          if (Math.random() > 0.5) steamParticles.push(new Steam());
        } else {
          finishBrew();
        }
      }, 30);
    };

    const stopBrewAction = () => {
      clearInterval(brewInterval);
      audioPour.pause(); audioPour.currentTime = 0;
    };

    brewBtn.addEventListener('touchstart', startBrewAction);
    brewBtn.addEventListener('mousedown', startBrewAction);
    brewBtn.addEventListener('touchend', stopBrewAction);
    brewBtn.addEventListener('mouseup', stopBrewAction);

    function finishBrew() {
      stopBrewAction();
      document.getElementById('screen-brew').style.display = 'none';
      document.getElementById('screen-drink').style.display = 'block';
      state = 'DRINK';
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(res => {
          if (res == 'granted') window.addEventListener('deviceorientation', handleDrinkTilt);
        });
      } else {
        window.addEventListener('deviceorientation', handleDrinkTilt);
      }
    }

    function handleDrinkTilt(event) {
      if (state !== 'DRINK') return;
      const tilt = event.beta;
      if (tilt < 60 && liquidLevel > 0) {
        liquidLevel -= 0.8;
        liquidOpacity = liquidLevel / 100;
        if (liquidLevel <= 0) finishDrink();
      }
    }

    window.debugDrink = () => {
      let drinkInt = setInterval(() => {
        liquidLevel -= 5;
        liquidOpacity = liquidLevel / 100;
        if (liquidLevel <= 0) {
          clearInterval(drinkInt);
          finishDrink();
        }
      }, 20);
    }

    function finishDrink() {
      window.removeEventListener('deviceorientation', handleDrinkTilt);
      document.getElementById('screen-drink').style.display = 'none';
      document.getElementById('screen-shake').style.display = 'block';
      state = 'SHAKE';
      window.addEventListener('devicemotion', handleMotion);
      window.addEventListener('deviceorientation', handleOrientation);
    }

    // SHAKE SENSORS
    let accX = 0, accY = 0, tiltX = 0, tiltY = 0;

    function handleMotion(e) {
      let acc = e.acceleration || e.accelerationIncludingGravity;
      if (acc) {
        let rx = acc.x || 0; let ry = acc.y || 0;
        accX = (Math.abs(rx) < 0.5) ? 0 : rx;
        accY = (Math.abs(ry) < 0.5) ? 0 : ry;
      }
    }

    function handleOrientation(e) {
      tiltX = e.gamma || 0;
      tiltY = e.beta || 0;
    }

    let stillFrames = 0;
    const revealBtn = document.getElementById('reveal-btn');

    function checkSettled() {
      let force = Math.abs(accX) + Math.abs(accY);
      let isInputLow = force < 2.5;
      let vel = 0;
      for (let i = 0; i < particles.length; i += 10) vel += Math.abs(particles[i].vx) + Math.abs(particles[i].vy);
      vel /= (particles.length / 10);

      if (isInputLow && vel < 0.8) stillFrames++;
      else {
        stillFrames = 0;
        revealBtn.style.display = 'none';
      }

      if (stillFrames > 30) revealBtn.style.display = 'block';
      return isInputLow;
    }

    // REVEAL
    revealBtn.addEventListener('click', async () => {
      state = 'REVEAL';
      document.getElementById('ui-layer').style.display = 'none';

      canvas.classList.add('canvas-reveal');

      const pBox = document.getElementById('prediction-box');
      pBox.style.display = 'block';
      setTimeout(() => pBox.classList.add('show'), 100);

      const tCanvas = document.createElement('canvas');
      tCanvas.width = 512; tCanvas.height = 512;
      const tCtx = tCanvas.getContext('2d');
      tCtx.fillStyle = "#fff"; tCtx.fillRect(0, 0, 512, 512);
      tCtx.drawImage(canvas, 0, 0, 512, 512);
      const base64 = tCanvas.toDataURL('image/jpeg', 0.6).split(',')[1];

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000);

      try {
        const res = await fetch('/api/predict', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ imageBase64: base64 }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const data = await res.json();
        document.getElementById('result-text').innerText = data.success ? data.prediction : "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏∑‡∏î‡∏ö‡∏î‡∏ö‡∏±‡∏á... ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà";
      } catch (e) {
        let msg = "‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢...";
        if (e.name === 'AbortError') msg = "‡∏£‡∏≠‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ... ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
        document.getElementById('result-text').innerText = msg;
      }
    });

  </script>
</body>

</html>