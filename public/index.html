<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>CPE Tasseography</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,700;1,600&family=Mali:wght@400;600&display=swap"
    rel="stylesheet">

  <style>
    :root {
      --bg-cream: #FFFDF5;
      --bg-warm: #FFE4C4;
      --porcelain: #FFFFFF;
      --gold: #D4AF37;
      --gold-light: #F4C430;
      --tea-green: #88B04B;
      --coffee-brown: #4E342E;
      --text-brown: #5D4037;
      --text-light: #8D6E63;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, var(--bg-cream), var(--bg-warm));
      color: var(--text-brown);
      font-family: 'Crimson Pro', serif;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Pattern overlay */
    body::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        radial-gradient(var(--gold) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: 0.1;
      z-index: -1;
      pointer-events: none;
    }

    canvas {
      display: block;
      filter: drop-shadow(0 20px 30px rgba(93, 64, 55, 0.2));
      transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .canvas-reveal {
      transform: translateY(-15%) scale(0.9);
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: opacity 0.4s;
    }

    /* PORCELAIN CARD STYLE */
    .porcelain-card {
      pointer-events: auto;
      background: var(--porcelain);
      border: 3px double var(--gold);
      border-radius: 25px;
      padding: 30px 25px;
      width: 85%;
      max-width: 380px;
      box-shadow: 0 10px 25px rgba(93, 64, 55, 0.15);
      text-align: center;
      position: relative;
    }

    .porcelain-card::after,
    .porcelain-card::before {
      content: "‚ùÄ";
      position: absolute;
      font-size: 1.5rem;
      color: var(--gold);
      opacity: 0.5;
    }

    .porcelain-card::after {
      top: 10px;
      right: 15px;
    }

    .porcelain-card::before {
      bottom: 10px;
      left: 15px;
    }

    h1,
    h2 {
      font-family: 'Crimson Pro', serif;
      font-weight: 700;
      font-style: italic;
      margin: 0 0 10px 0;
      color: var(--text-brown);
    }

    p {
      color: var(--text-light);
      font-family: 'Mali', cursive;
      font-size: 1.1rem;
      margin-bottom: 25px;
    }

    input[type="text"] {
      width: 100%;
      background: #FFFBF0;
      border: 1px solid var(--gold);
      border-radius: 15px;
      padding: 12px;
      color: var(--text-brown);
      font-family: 'Mali', cursive;
      font-size: 1.1rem;
      margin-bottom: 20px;
      outline: none;
      text-align: center;
    }

    /* DRINK BUTTONS */
    .tea-btn {
      display: inline-block;
      border: none;
      background: linear-gradient(to bottom, #fff, #f9f9f9);
      min-width: 180px;
      padding: 12px 30px;
      margin: 8px;
      border-radius: 50px;
      cursor: pointer;
      font-family: 'Mali', cursive;
      font-weight: 600;
      font-size: 1rem;
      color: var(--text-brown);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1), inset 0 0 0 2px var(--gold);
      transition: transform 0.2s;
    }

    .tea-btn:active {
      transform: scale(0.95);
    }

    .tea-btn.green {
      color: #558B2F;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1), inset 0 0 0 2px #AED581;
    }

    .tea-btn.coffee {
      color: #4E342E;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1), inset 0 0 0 2px #8D6E63;
    }

    /* BREW BUTTON */
    #brew-btn-container {
      position: relative;
      width: 130px;
      height: 130px;
      margin: 0 auto;
    }

    #brew-btn {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: white;
      border: 4px solid var(--gold);
      color: var(--text-brown);
      font-family: 'Crimson Pro';
      font-weight: bold;
      font-size: 1.3rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: 0.2s;
    }

    #brew-btn.active {
      transform: scale(0.95);
      background: #FFF8E1;
    }

    .progress-ring {
      position: absolute;
      top: -5px;
      left: -5px;
      transform: rotate(-90deg);
      pointer-events: none;
    }

    .progress-ring__circle {
      transition: 0.1s stroke-dashoffset;
      stroke: var(--gold);
    }

    /* PREDICTION BOX */
    #prediction-box {
      display: none;
      pointer-events: auto;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 55vh;
      background: #FFFDF9;
      border-top: 5px solid var(--gold);
      border-radius: 30px 30px 0 0;
      box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.1);
      padding: 30px 25px;
      transform: translateY(100%);
      transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
      z-index: 100;
    }

    #prediction-box.show {
      transform: translateY(0);
    }

    #result-text {
      font-size: 1.2rem;
      line-height: 1.8;
      color: var(--text-brown);
      border-left: 3px solid var(--gold);
      padding-left: 15px;
      margin: 15px 0;
      font-family: 'Mali', cursive;
    }

    /* UTILS */
    .float-text {
      background: rgba(255, 255, 255, 0.8);
      padding: 8px 20px;
      border-radius: 20px;
      border: 1px solid var(--gold);
      font-family: 'Mali', cursive;
    }

    #shake-meter {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 10px;
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid var(--gold);
      border-radius: 10px;
      display: none;
      z-index: 20;
      overflow: hidden;
    }

    #shake-meter-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--tea-green), var(--gold));
      transition: width 0.1s;
    }

    #match-hint {
      position: fixed;
      top: 40px;
      width: 100%;
      text-align: center;
      color: var(--text-brown);
      font-family: 'Mali', cursive;
      display: none;
      z-index: 20;
      text-shadow: 0 0 5px white;
    }

    .debug-btn {
      position: fixed;
      bottom: 10px;
      right: 10px;
      font-size: 0.7rem;
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.1);
      border: 1px solid #ccc;
      border-radius: 5px;
      cursor: pointer;
      pointer-events: auto;
      z-index: 200;
      color: #555;
    }
  </style>
</head>

<body>

  <audio id="audio-pour" loop>
    <source src="pour.mp3" type="audio/mpeg">
  </audio>

  <div id="shake-meter">
    <div id="shake-meter-fill"></div>
  </div>
  <div id="match-hint"></div>

  <canvas id="canvas"></canvas>

  <div id="ui-layer">

    <div id="screen-select" class="porcelain-card">
      <h2>CPE Tea Room</h2>
      <p>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏î‡∏∑‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡∏ä‡∏∞‡∏ï‡∏≤</p>

      <input type="text" id="user-question" placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏≤‡∏Å‡∏£‡∏π‡πâ..." autocomplete="off">

      <div style="margin-top:10px;">
        <button class="tea-btn green" onclick="selectDrink('TEA')">üçÉ ‡πÉ‡∏ö‡∏ä‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß</button>
        <button class="tea-btn coffee" onclick="selectDrink('COFFEE')">‚òï ‡∏Å‡∏≤‡πÅ‡∏ü‡∏Ñ‡∏±‡πà‡∏ß</button>
      </div>
    </div>

    <div id="screen-brew" style="display:none; pointer-events:auto; text-align:center;">
      <p class="float-text">‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏¥‡∏ô‡∏ô‡πâ‡∏≥‡∏£‡πâ‡∏≠‡∏ô</p>
      <div style="height:20px;"></div>
      <div id="brew-btn-container">
        <svg class="progress-ring" width="140" height="140">
          <circle class="progress-ring__circle" stroke-width="6" fill="transparent" r="60" cx="70" cy="70"
            stroke-dasharray="377" stroke-dashoffset="377" />
        </svg>
        <div id="brew-btn">POUR</div>
      </div>
    </div>

    <div id="screen-drink" style="display:none; pointer-events:auto; width:100%; text-align:center; justify-items: center;">
      <div style="font-size:5rem; margin-bottom:15px;" id="drink-icon">üçµ</div>
      <h2>Sip Slowly</h2>
      <p class="float-text">‡πÄ‡∏≠‡∏µ‡∏¢‡∏á‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∑‡πà‡∏°‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏î‡∏ñ‡πâ‡∏ß‡∏¢</p>

      <button class="debug-btn" onclick="debugDrink()">[Debug: Drink]</button>
    </div>

    <div id="screen-shake" style="display:none; text-align:center;">
      <h1>Shake Gently</h1>
      <p class="float-text">‡πÄ‡∏Ç‡∏¢‡πà‡∏≤‡πÄ‡∏ö‡∏≤ ‡πÜ ‡πÉ‡∏´‡πâ‡∏ï‡∏∞‡∏Å‡∏≠‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß</p>

      <div style="margin-top:40px;">
        <button id="reveal-btn" class="tea-btn green"
          style="display:none; pointer-events:auto; font-size:1.2rem; padding:15px 40px;">
          ‚ú® ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ ‚ú®
        </button>
      </div>

      <button class="debug-btn" onclick="debugShake()">[Debug: Shake]</button>
    </div>
  </div>

  <div id="prediction-box">
    <div style="height: 100%; overflow-y: auto;">
      <div style="width: 50px; height: 4px; background: var(--gold); margin: 0 auto 20px; border-radius: 2px;"></div>
      <h3 style="text-align:center; font-family:'Crimson Pro'; color:var(--text-brown); font-size:1.5rem;">The Prediction
      </h3>

      <div id="result-text">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏à‡∏¥‡∏ï‡∏ß‡∏¥‡∏ç‡∏ç‡∏≤‡∏ì...</div>

      <div style="text-align:center; margin-top:30px;">
        <button onclick="location.reload()" class="tea-btn coffee">
          ‡πÄ‡∏•‡πà‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        </button>
      </div>
    </div>
  </div>

  <script>
    // ============================================================
    // SYMBOLS (From User Request)
    // ============================================================
    const SYMBOLS = [
      {
        name: "Crescent Moon", nameTH: "‡πÄ‡∏™‡∏µ‡πâ‡∏¢‡∏ß‡∏û‡∏£‡∏∞‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå",
        meaning: "receptivity; lunar; introspection",
        meaningTH: "‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏£‡∏π‡πâ ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏á‡∏ö‡∏†‡∏≤‡∏¢‡πÉ‡∏ô",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = -Math.PI * 0.7; a <= Math.PI * 0.7; a += 0.18)
            pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
          const inner = r * 0.65, ox = r * 0.3;
          for (let a = Math.PI * 0.7; a >= -Math.PI * 0.7; a -= 0.18)
            pts.push({ x: cx + ox + inner * Math.cos(a), y: cy + inner * Math.sin(a) });
          return pts;
        }
      },
      {
        name: "Heart", nameTH: "‡∏´‡∏±‡∏ß‡πÉ‡∏à",
        meaning: "love; romance; home",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å ‚Ä¢ ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏£‡∏±‡∏ß ‚Ä¢ ‡∏ö‡πâ‡∏≤‡∏ô",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let t = 0; t <= Math.PI * 2; t += 0.12) {
            const x = r * 0.9 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = -r * 0.9 * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;
            pts.push({ x: cx + x, y: cy + y });
          }
          return pts;
        }
      },
      {
        name: "Star", nameTH: "‡∏î‡∏≤‡∏ß",
        meaning: "good luck; excellence; success",
        meaningTH: "‡πÇ‡∏ä‡∏Ñ‡∏î‡∏µ ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
        draw: (cx, cy, r) => {
          const pts = [], spikes = 5, inner = r * 0.45;
          for (let i = 0; i < spikes * 2; i++) {
            const rad = i % 2 === 0 ? r : inner;
            const a = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
            const next_rad = (i + 1) % 2 === 0 ? r : inner;
            const next_a = ((i + 1) / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
            for (let t = 0; t <= 1; t += 0.25) {
              const ir = rad + (next_rad - rad) * t;
              const ia = a + (next_a - a) * t;
              pts.push({ x: cx + ir * Math.cos(ia), y: cy + ir * Math.sin(ia) });
            }
          }
          return pts;
        }
      },
      {
        name: "Spiral", nameTH: "‡∏ß‡∏ô‡∏Å‡πâ‡∏ô‡∏´‡∏≠‡∏¢",
        meaning: "creativity; energy; time for problem solving",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏¥‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏™‡∏£‡∏£‡∏Ñ‡πå ‚Ä¢ ‡∏û‡∏•‡∏±‡∏á‡∏á‡∏≤‡∏ô",
        draw: (cx, cy, r) => {
          const pts = [], turns = 2.5;
          for (let t = 0.1; t <= turns * Math.PI * 2; t += 0.15) {
            const rad = (t / (turns * Math.PI * 2)) * r;
            pts.push({ x: cx + rad * Math.cos(t), y: cy + rad * Math.sin(t) });
          }
          return pts;
        }
      },
      {
        name: "Horseshoe", nameTH: "‡πÄ‡∏Å‡∏∑‡∏≠‡∏Å‡∏°‡πâ‡∏≤",
        meaning: "good luck",
        meaningTH: "‡πÇ‡∏ä‡∏Ñ‡∏•‡∏≤‡∏† ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÇ‡∏ä‡∏Ñ‡∏î‡∏µ",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = Math.PI * 0.1; a <= Math.PI * 0.9; a += 0.15)
            pts.push({ x: cx + r * Math.cos(a + Math.PI), y: cy - r * 0.85 * Math.sin(a) });
          for (let y = 0; y <= r * 0.6; y += r * 0.1) pts.push({ x: cx - r * 0.85, y: cy - r * 0.4 + y });
          for (let y = 0; y <= r * 0.6; y += r * 0.1) pts.push({ x: cx + r * 0.85, y: cy - r * 0.4 + y });
          return pts;
        }
      },
      {
        name: "Sun", nameTH: "‡∏î‡∏ß‡∏á‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå",
        meaning: "energy; power; success; new beginnings",
        meaningTH: "‡∏û‡∏•‡∏±‡∏á ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Ä¢ ‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI * 2; a += 0.22)
            pts.push({ x: cx + r * 0.45 * Math.cos(a), y: cy + r * 0.45 * Math.sin(a) });
          for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2;
            for (let t = 0.5; t <= 1; t += 0.15)
              pts.push({ x: cx + r * t * Math.cos(a), y: cy + r * t * Math.sin(a) });
          }
          return pts;
        }
      },
      {
        name: "Anchor", nameTH: "‡∏™‡∏°‡∏≠‡πÄ‡∏£‡∏∑‡∏≠",
        meaning: "stability; difficult to change",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏±‡πà‡∏ô‡∏Ñ‡∏á ‚Ä¢ ‡∏£‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏Å‡∏£‡πà‡∏á",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI * 2; a += 0.3)
            pts.push({ x: cx + r * 0.2 * Math.cos(a), y: cy - r * 0.7 + r * 0.2 * Math.sin(a) });
          for (let y = -r * 0.5; y <= r * 0.6; y += r * 0.1) pts.push({ x: cx, y: cy + y });
          for (let x = -r * 0.5; x <= r * 0.5; x += r * 0.1) pts.push({ x: cx + x, y: cy - r * 0.35 });
          for (let a = 0; a <= Math.PI; a += 0.2)
            pts.push({ x: cx + r * 0.55 * Math.cos(Math.PI + a), y: cy + r * 0.6 + r * 0.3 * Math.sin(Math.PI + a) });
          pts.push({ x: cx - r * 0.55, y: cy + r * 0.3 }, { x: cx + r * 0.55, y: cy + r * 0.3 });
          return pts;
        }
      },
      {
        name: "Cross", nameTH: "‡∏Å‡∏≤‡∏Å‡∏ö‡∏≤‡∏ó",
        meaning: "plus; addition; crossroads",
        meaningTH: "‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏û‡∏π‡∏ô ‚Ä¢ ‡∏ö‡∏ß‡∏Å ‚Ä¢ ‡∏ó‡∏≤‡∏á‡πÅ‡∏¢‡∏Å",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let y = -r * 0.8; y <= r * 0.8; y += r * 0.1) pts.push({ x: cx, y: cy + y });
          for (let x = -r * 0.8; x <= r * 0.8; x += r * 0.1) pts.push({ x: cx + x, y: cy });
          return pts;
        }
      },
      {
        name: "Water / Waves", nameTH: "‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ô‡πâ‡∏≥",
        meaning: "sea; unity; travel",
        meaningTH: "‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏±‡∏Ñ‡∏Ñ‡∏µ",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let row = -1; row <= 1; row++)
            for (let x = -r * 0.85; x <= r * 0.85; x += r * 0.08)
              pts.push({ x: cx + x, y: cy + row * r * 0.3 + Math.sin((x / r) * Math.PI * 3) * r * 0.12 });
          return pts;
        }
      },
      {
        name: "Arrow Up", nameTH: "‡∏•‡∏π‡∏Å‡∏®‡∏£‡∏Ç‡∏∂‡πâ‡∏ô",
        meaning: "yes; good direction",
        meaningTH: "‡πÉ‡∏ä‡πà ‚Ä¢ ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ ‚Ä¢ ‡∏Å‡πâ‡∏≤‡∏ß‡∏´‡∏ô‡πâ‡∏≤",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let y = -r * 0.5; y <= r * 0.8; y += r * 0.1) pts.push({ x: cx, y: cy + y });
          for (let t = 0; t <= 1; t += 0.1) {
            pts.push({ x: cx - r * 0.45 * t, y: cy - r * 0.5 + r * 0.5 * t });
            pts.push({ x: cx + r * 0.45 * t, y: cy - r * 0.5 + r * 0.5 * t });
          }
          return pts;
        }
      },
      {
        name: "Eye / Circle", nameTH: "‡∏ß‡∏á‡∏Å‡∏•‡∏°",
        meaning: "totality; bringing together",
        meaningTH: "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå ‚Ä¢ ‡∏£‡∏ß‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI * 2; a += 0.13)
            pts.push({ x: cx + r * 0.75 * Math.cos(a), y: cy + r * 0.75 * Math.sin(a) });
          for (let a = 0; a <= Math.PI * 2; a += 0.3)
            pts.push({ x: cx + r * 0.15 * Math.cos(a), y: cy + r * 0.15 * Math.sin(a) });
          return pts;
        }
      },
      {
        name: "Peace", nameTH: "‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏™‡∏±‡∏ô‡∏ï‡∏¥",
        meaning: "peace",
        meaningTH: "‡∏™‡∏±‡∏ô‡∏ï‡∏¥‡∏†‡∏≤‡∏û ‚Ä¢ ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏á‡∏ö",
        draw: (cx, cy, r) => {
          const pts = [];
          for (let a = 0; a <= Math.PI * 2; a += 0.18)
            pts.push({ x: cx + r * 0.75 * Math.cos(a), y: cy + r * 0.75 * Math.sin(a) });
          for (let y = -r * 0.75; y <= r * 0.75; y += r * 0.1) pts.push({ x: cx, y: cy + y });
          for (let t = 0; t <= 1; t += 0.12) {
            pts.push({ x: cx - r * 0.75 * 0.7 * t, y: cy + r * 0.75 * 0.7 * t });
            pts.push({ x: cx + r * 0.75 * 0.7 * t, y: cy + r * 0.75 * 0.7 * t });
          }
          return pts;
        }
      },
    ];

    // ============================================================
    // VISUAL SETUP
    // ============================================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const CUP_RADIUS = Math.min(canvas.width, canvas.height) * 0.38;
    const CENTER_X = canvas.width / 2;
    const CENTER_Y = canvas.height / 2;

    let state = 'SELECT';
    let drinkType = 'TEA';
    let liquidLevel = 0;
    let liquidOpacity = 0;
    const audioPour = document.getElementById('audio-pour');

    let particles = [];
    let steamParticles = [];
    let chosenSymbol = null;
    let symbolFormProgress = 0;
    let shakeEnergy = 0;

    // ============================================================
    // PARTICLES (Tea Leaves & Coffee Grounds)
    // ============================================================
    class Particle {
      constructor(type) {
        const angle = Math.random() * Math.PI * 2;
        const r = Math.sqrt(Math.random()) * CUP_RADIUS;
        this.x = CENTER_X + r * Math.cos(angle);
        this.y = CENTER_Y + r * Math.sin(angle);
        this.type = type; // 'LEAF' or 'DUST'

        // Physics
        this.mass = (type === 'LEAF') ? (2.0 + Math.random() * 3.0) : (0.5 + Math.random());
        this.vx = 0; this.vy = 0;
        this.friction = 0.92;
        this.rotation = Math.random() * Math.PI;

        // Color Logic
        if (drinkType === 'TEA') {
          // Green Tea Leaves
          const greens = ['#558B2F', '#7CB342', '#33691E'];
          this.color = greens[Math.floor(Math.random() * greens.length)];
          this.scale = 1;
        } else {
          // Coffee Grounds (Darker, Smaller)
          const browns = ['#3E2723', '#4E342E', '#211613'];
          this.color = browns[Math.floor(Math.random() * browns.length)];
          this.mass *= 0.8; // Grounds are lighter/smaller
          this.scale = 0.7;
        }

        this.vertices = [];
        let size = this.mass * 2.5 * this.scale;
        let points = (drinkType === 'TEA') ? (4 + Math.floor(Math.random() * 3)) : 3;

        for (let i = 0; i < points; i++) {
          let th = (i / points) * Math.PI * 2;
          let rad = size * (0.7 + Math.random() * 0.4);
          this.vertices.push({ x: Math.cos(th) * rad, y: Math.sin(th) * rad });
        }

        this.targetX = null; this.targetY = null;
        this.hasTarget = false;
        this.noisePhase = Math.random() * 100;
      }

      update(inputLow) {
        if (state !== 'SHAKE') return;
        this.noisePhase += 0.05;

        if (this.hasTarget && symbolFormProgress > 0) {
          const pull = symbolFormProgress * 0.08;
          this.vx += (this.targetX - this.x) * pull;
          this.vy += (this.targetY - this.y) * pull;
        }

        const noiseX = inputLow ? 0 : Math.cos(this.noisePhase) * 0.5;
        const noiseY = inputLow ? 0 : Math.sin(this.noisePhase) * 0.5;

        this.vx -= (accX + noiseX) * 1.5 / this.mass;
        this.vy -= (accY + noiseY) * 1.5 / this.mass;
        this.vx += tiltX * 0.08;
        this.vy += tiltY * 0.08;
        this.vx *= this.friction;
        this.vy *= this.friction;

        this.x += this.vx;
        this.y += this.vy;

        const dx = this.x - CENTER_X;
        const dy = this.y - CENTER_Y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > CUP_RADIUS * 0.9) {
          let ang = Math.atan2(dy, dx);
          this.x = CENTER_X + Math.cos(ang) * CUP_RADIUS * 0.9;
          this.y = CENTER_Y + Math.sin(ang) * CUP_RADIUS * 0.9;
          this.vx *= -0.3;
          this.vy *= -0.3;
        }
      }

      draw() {
        let alpha = 1;
        if (state === 'BREW') alpha = 0.1;
        if (state === 'DRINK') alpha = 1 - (liquidOpacity * 0.95); // Fade more in drink phase

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;

        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
        for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }

    class Steam {
      constructor() {
        this.x = CENTER_X + (Math.random() - 0.5) * CUP_RADIUS * 0.8;
        this.y = CENTER_Y + (Math.random() - 0.5) * CUP_RADIUS * 0.8;
        this.vx = (Math.random() - 0.5) * 0.2;
        this.vy = -0.5 - Math.random() * 0.5;
        this.size = 10 + Math.random() * 20;
        this.life = 100;
        this.maxLife = 100;
      }
      update() { this.x += this.vx; this.y += this.vy; this.size += 0.1; this.life--; }
      draw() {
        ctx.save();
        ctx.globalAlpha = (this.life / this.maxLife) * 0.15;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.filter = "blur(8px)";
        ctx.fill();
        ctx.restore();
      }
    }

    // ============================================================
    // MATCHING LOGIC
    // ============================================================
    function computeDensityGrid(pts, gridSize = 8) {
      const grid = new Float32Array(gridSize * gridSize);
      for (const p of pts) {
        const nx = (p.x - CENTER_X) / CUP_RADIUS;
        const ny = (p.y - CENTER_Y) / CUP_RADIUS;
        const gx = Math.floor((nx + 1) / 2 * gridSize);
        const gy = Math.floor((ny + 1) / 2 * gridSize);
        if (gx >= 0 && gx < gridSize && gy >= 0 && gy < gridSize) grid[gy * gridSize + gx]++;
      }
      const max = Math.max(...grid, 1);
      for (let i = 0; i < grid.length; i++) grid[i] /= max;
      return grid;
    }

    function cosineSimilarity(a, b) {
      let dot = 0, normA = 0, normB = 0;
      for (let i = 0; i < a.length; i++) {
        dot += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      if (normA === 0 || normB === 0) return 0;
      return dot / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    function findBestMatchingSymbol() {
      const particlePts = particles.map(p => ({ x: p.x, y: p.y }));
      const particleGrid = computeDensityGrid(particlePts);
      let bestSymbol = SYMBOLS[0], bestScore = -Infinity;

      for (const sym of SYMBOLS) {
        const symPts = sym.draw(CENTER_X, CENTER_Y, CUP_RADIUS * 0.7);
        const symGrid = computeDensityGrid(symPts);
        const score = cosineSimilarity(particleGrid, symGrid);
        if (score > bestScore) { bestScore = score; bestSymbol = sym; }
      }
      return { symbol: bestSymbol, confidence: bestScore };
    }

    function assignTargetsToSymbol(symbol) {
      chosenSymbol = symbol;
      const rawPts = symbol.draw(CENTER_X, CENTER_Y, CUP_RADIUS * 0.7);
      particles.forEach((p, i) => {
        const tp = rawPts[i % rawPts.length];
        p.targetX = tp.x + (Math.random() - 0.5) * 20;
        p.targetY = tp.y + (Math.random() - 0.5) * 20;
        p.hasTarget = true;
      });
    }

    // ============================================================
    // DRAW LOOP
    // ============================================================
    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 1. Saucer
      ctx.save();
      ctx.beginPath();
      ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS + 30, 0, Math.PI * 2);
      ctx.fillStyle = "#FFFBF0";
      ctx.shadowBlur = 15; ctx.shadowColor = "rgba(0,0,0,0.1)";
      ctx.fill();
      ctx.strokeStyle = "#D4AF37"; ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();

      // 2. Cup Interior
      ctx.save();
      ctx.beginPath();
      ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS, 0, Math.PI * 2);
      let cupGrad = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, CUP_RADIUS);
      cupGrad.addColorStop(0, '#FFFFFF');
      cupGrad.addColorStop(1, '#E0E0E0');
      ctx.fillStyle = cupGrad; ctx.fill();
      ctx.clip();

      // 3. Particles
      let isLow = checkSettled();
      particles.forEach(p => {
        if (state === 'SHAKE') p.update(isLow);
        p.draw();
      });

      // 4. Liquid
      if (liquidOpacity > 0) {
        let teaGrad = ctx.createRadialGradient(CENTER_X - 20, CENTER_Y - 20, 10, CENTER_X, CENTER_Y, CUP_RADIUS);
        if (drinkType === 'TEA') {
          // Green Tea (Clear Green)
          teaGrad.addColorStop(0, `rgba(160, 200, 100, ${liquidOpacity * 0.92})`);
          teaGrad.addColorStop(1, `rgba(80, 120, 40, ${liquidOpacity * 0.95})`);
        } else {
          // Coffee (Dark Roast)
          teaGrad.addColorStop(0, `rgba(80, 50, 40, ${liquidOpacity * 0.95})`);
          teaGrad.addColorStop(1, `rgba(30, 15, 10, ${liquidOpacity * 0.98})`);
        }
        ctx.fillStyle = teaGrad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      steamParticles.forEach((s, i) => { s.update(); s.draw(); if (s.life <= 0) steamParticles.splice(i, 1); });
      ctx.restore();

      // 5. Cup Rim
      ctx.save();
      ctx.beginPath();
      ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS, 0, Math.PI * 2);
      ctx.lineWidth = 6; ctx.strokeStyle = "#D4AF37"; ctx.stroke();
      ctx.beginPath();
      ctx.arc(CENTER_X, CENTER_Y, CUP_RADIUS - 8, 0, Math.PI * 2);
      ctx.lineWidth = 1; ctx.strokeStyle = "rgba(212, 175, 55, 0.5)"; ctx.stroke();
      ctx.restore();

      requestAnimationFrame(loop);
    }

    // ============================================================
    // LOGIC & DEBUG
    // ============================================================
    window.selectDrink = async (type) => {
      drinkType = type;
      if (type === 'TEA') {
        document.getElementById('drink-icon').innerText = 'üçµ';
      } else {
        document.getElementById('drink-icon').innerText = '‚òï';
      }

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch (e) { }
      }

      document.getElementById('screen-select').style.opacity = '0';
      setTimeout(() => {
        document.getElementById('screen-select').style.display = 'none';
        document.getElementById('screen-brew').style.display = 'block';
        state = 'BREW';
        initParticles();
      }, 400);
    };

    function initParticles() {
      particles = [];
      let count = (drinkType === 'TEA') ? 600 : 800; // Coffee has more fine grains
      for (let i = 0; i < count; i++) {
        let t = Math.random() > 0.6 ? 'LEAF' : 'DUST';
        particles.push(new Particle(t));
      }
      loop();
    }

    // --- BREW LOGIC ---
    const brewBtn = document.getElementById('brew-btn');
    const progressCircle = document.querySelector('.progress-ring__circle');
    const circumference = 2 * Math.PI * 60;
    progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
    progressCircle.style.strokeDashoffset = circumference;

    let brewInterval;
    const startBrew = (e) => {
      if (e) e.preventDefault();
      if (liquidLevel >= 100) return;
      brewBtn.classList.add('active');
      try { audioPour.play(); } catch (e) { }

      brewInterval = setInterval(() => {
        if (liquidLevel < 100) {
          liquidLevel += 1.5;
          liquidOpacity = liquidLevel / 100;
          const offset = circumference - (liquidLevel / 100) * circumference;
          progressCircle.style.strokeDashoffset = offset;
          if (Math.random() > 0.6) steamParticles.push(new Steam());
        } else { finishBrew(); }
      }, 30);
    };

    const stopBrew = () => {
      clearInterval(brewInterval);
      brewBtn.classList.remove('active');
      audioPour.pause();
    };
    brewBtn.addEventListener('touchstart', startBrew);
    brewBtn.addEventListener('mousedown', startBrew);
    brewBtn.addEventListener('touchend', stopBrew);
    brewBtn.addEventListener('mouseup', stopBrew);

    function finishBrew() {
      stopBrew();
      document.getElementById('screen-brew').style.display = 'none';
      document.getElementById('screen-drink').style.display = 'block';
      state = 'DRINK';
      window.addEventListener('deviceorientation', handleDrinkTilt);
    }

    // --- DRINK LOGIC ---
    function handleDrinkTilt(event) {
      if (state !== 'DRINK') return;
      if (event.beta > 60 && liquidLevel > 0) {
        liquidLevel -= 2;
        liquidOpacity = liquidLevel / 100;
        if (liquidLevel <= 0) finishDrink();
      }
    }

    // *** RESTORED FUNCTION: debugDrink ***
    window.debugDrink = () => {
      let iv = setInterval(() => {
        liquidLevel -= 2;
        liquidOpacity = liquidLevel / 100;
        if (liquidLevel <= 0) {
          clearInterval(iv);
          finishDrink();
        }
      }, 30);
    };

    function finishDrink() {
      window.removeEventListener('deviceorientation', handleDrinkTilt);
      document.getElementById('screen-drink').style.display = 'none';
      document.getElementById('screen-shake').style.display = 'block';
      state = 'SHAKE';
      document.getElementById('shake-meter').style.display = 'block';
      document.getElementById('match-hint').style.display = 'block';
      window.addEventListener('devicemotion', handleMotion);
      window.addEventListener('deviceorientation', handleOrientation);
    }

    // --- SHAKE LOGIC ---
    let accX = 0, accY = 0, tiltX = 0, tiltY = 0, prevAccX = 0, prevAccY = 0;
    function handleMotion(e) {
      let acc = e.acceleration || e.accelerationIncludingGravity;
      if (acc) {
        accX = (Math.abs(acc.x) < 0.5) ? 0 : acc.x;
        accY = (Math.abs(acc.y) < 0.5) ? 0 : acc.y;
        shakeEnergy = Math.abs(accX - prevAccX) + Math.abs(accY - prevAccY);
        prevAccX = accX; prevAccY = accY;
      }
    }
    function handleOrientation(e) { tiltX = e.gamma || 0; tiltY = e.beta || 0; }

    // *** RESTORED FUNCTION: debugShake ***
    window.debugShake = () => {
      let t = 0;
      const iv = setInterval(() => {
        accX = Math.sin(t) * 15;
        accY = Math.cos(t) * 15;
        shakeEnergy = 20;
        t += 0.5;
        if (t > 15) { // Shake for a bit then stop
          clearInterval(iv);
          accX = 0; accY = 0; shakeEnergy = 0;
        }
      }, 50);
    };

    let stillFrames = 0, totalShakeEnergy = 0, hasShaken = false, matchingDone = false;
    const SHAKE_THRESHOLD = 80;
    const revealBtn = document.getElementById('reveal-btn');

    function checkSettled() {
      if (state !== 'SHAKE') return true;
      let force = Math.abs(accX) + Math.abs(accY);
      let isInputLow = force < 2.5;

      if (!isInputLow) {
        totalShakeEnergy += shakeEnergy;
        if (totalShakeEnergy >= SHAKE_THRESHOLD) { hasShaken = true; matchingDone = false; }
        const pct = Math.min(totalShakeEnergy / SHAKE_THRESHOLD * 100, 100);
        document.getElementById('shake-meter-fill').style.width = pct + '%';
      }

      if (hasShaken && isInputLow) {
        stillFrames++;
        if (!matchingDone && stillFrames === 40) {
          const { symbol } = findBestMatchingSymbol();
          assignTargetsToSymbol(symbol);
          matchingDone = true;
          document.getElementById('match-hint').innerHTML = `‚ú® ‡∏£‡∏π‡∏õ‡∏ó‡∏£‡∏á‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢... <strong>${symbol.nameTH}</strong>`;
        }
        if (symbolFormProgress < 1 && matchingDone) symbolFormProgress += 0.01;
      } else {
        if (!hasShaken || !isInputLow) {
          stillFrames = 0;
          revealBtn.style.display = 'none';
          if (!isInputLow) {
            matchingDone = false;
            symbolFormProgress = Math.max(0, symbolFormProgress - 0.05);
            particles.forEach(p => p.hasTarget = false);
            document.getElementById('match-hint').innerText = "‡πÄ‡∏Ç‡∏¢‡πà‡∏≤‡πÄ‡∏ö‡∏≤‡πÜ...";
          }
        }
      }

      if (hasShaken && stillFrames > 60) revealBtn.style.display = 'inline-block';
      return isInputLow;
    }

    // --- REVEAL (BACKEND CONNECTED) ---
    revealBtn.addEventListener('click', async () => {
      state = 'REVEAL';
      document.getElementById('ui-layer').style.display = 'none';
      document.getElementById('shake-meter').style.display = 'none';
      document.getElementById('match-hint').style.display = 'none';
      canvas.classList.add('canvas-reveal');

      const pBox = document.getElementById('prediction-box');
      pBox.style.display = 'block';
      setTimeout(() => pBox.classList.add('show'), 100);

      if (chosenSymbol) {
        document.getElementById('result-text').innerHTML =
          `<strong>‚ú® ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏≤‡∏Å‡∏è: ${chosenSymbol.nameTH}</strong><br>` +
          `<em>(${chosenSymbol.name})</em><br><br>` +
          `‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢: ${chosenSymbol.meaningTH}<br><br>` +
          `‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£‡∏Å‡∏±‡∏ö‡∏à‡∏¥‡∏ï‡∏ß‡∏¥‡∏ç‡∏ç‡∏≤‡∏ì...`;
      }

      // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏≤‡∏Å‡∏£‡∏π‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÑ‡∏õ‡∏ä‡πà‡∏ß‡∏¢ AI ‡∏ú‡∏π‡∏Å‡∏Ñ‡∏≥‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏≤‡∏°
      const userQuestion = document.getElementById('user-question')?.value || '';

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60000);

      try {
        const res = await fetch('/api/predict', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            symbolName: chosenSymbol ? chosenSymbol.name : '',
            symbolMeaning: chosenSymbol ? chosenSymbol.meaning : '',
            symbolNameTH: chosenSymbol ? chosenSymbol.nameTH : '',
            symbolMeaningTH: chosenSymbol ? chosenSymbol.meaningTH : '',
            userQuestion
          }),
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const data = await res.json();
        if (data.success) {
          document.getElementById('result-text').innerHTML =
            `<strong>‚ú® ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå: ${chosenSymbol ? chosenSymbol.nameTH : ''}</strong><br><br>` +
            data.prediction;
        } else {
          document.getElementById('result-text').innerText = "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏∑‡∏î‡∏ö‡∏î‡∏ö‡∏±‡∏á... ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà";
        }
      } catch (e) {
        clearTimeout(timeoutId);
        let msg = "‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏Ç‡∏≤‡∏î‡∏´‡∏≤‡∏¢...";
        if (e.name === 'AbortError') msg = "‡∏£‡∏≠‡∏ô‡∏≤‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ... ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
        if (chosenSymbol) {
          document.getElementById('result-text').innerHTML =
            `<strong>‚ú® ‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏≤‡∏Å‡∏è: ${chosenSymbol.nameTH}</strong><br><br>` +
            `${chosenSymbol.meaningTH}<br><br><em>${msg}</em>`;
        } else {
          document.getElementById('result-text').innerText = msg;
        }
      }
    });
  </script>
</body>

</html>